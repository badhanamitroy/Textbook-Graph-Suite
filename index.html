<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Textbook Graph Suite</title>
<style>
  :root{
    --bg:#0b1020; --panel:#111a33; --text:#e9eefc; --muted:#9fb0e6; --stroke:rgba(255,255,255,0.10);
    --good: rgba(61,220,151,0.14);
    --goodBorder: rgba(61,220,151,0.35);
  }
  body{
    margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
    background:linear-gradient(180deg,#070b16,#0b1020);
    color:var(--text);
    min-height:100vh;
  }
  .topbar{
    position:sticky; top:0; z-index:10;
    background:rgba(7,11,22,0.78);
    backdrop-filter: blur(10px);
    border-bottom:1px solid rgba(255,255,255,0.10);
  }
  .topbarInner{
    width:min(1400px,96vw);
    margin:0 auto;
    padding:10px 0;
    display:flex;
    gap:12px;
    align-items:center;
    justify-content:space-between;
  }
  .brand{ display:flex; flex-direction:column; gap:2px; }
  .brand b{ font-size:14px; letter-spacing:.2px; }
  .brand span{ color:var(--muted); font-size:12px; }
  .tabs{ display:flex; gap:8px; flex-wrap:wrap; }
  .tab{
    border:1px solid rgba(255,255,255,0.14);
    background:rgba(255,255,255,0.06);
    color:var(--text);
    padding:9px 12px;
    border-radius:999px;
    cursor:pointer;
    font-weight:800;
    font-size:13px;
  }
  .tab.active{
    background:rgba(255,255,255,0.14);
    border-color:rgba(255,255,255,0.22);
  }
  .wrap{ width:min(1400px,96vw); margin:0 auto; padding:16px 0 22px; }
  .app{ display:none; }
  .app.active{ display:block; }

  .grid{
    display:grid;
    grid-template-columns: 560px 1fr;
    gap:16px; align-items:start;
  }
  @media (max-width: 980px){ .grid{ grid-template-columns: 1fr; } }

  .card{
    background:rgba(17,26,51,0.88);
    border:1px solid var(--stroke);
    border-radius:18px;
    box-shadow:0 20px 55px rgba(0,0,0,0.45);
    overflow:hidden;
  }
  .card h2{
    margin:0; padding:14px 16px; font-size:16px;
    border-bottom:1px solid var(--stroke);
    display:flex; align-items:center; justify-content:space-between; gap:12px;
  }
  .pill{
    font-size:12px; color:var(--muted);
    border:1px solid rgba(255,255,255,0.12);
    padding:6px 10px; border-radius:999px;
    background:rgba(0,0,0,0.18); white-space:nowrap;
  }
  .body{ padding:14px 16px; }
  textarea,input,select{
    width:100%; box-sizing:border-box;
    background:rgba(0,0,0,0.25);
    border:1px solid rgba(255,255,255,0.12);
    color:var(--text);
    border-radius:12px;
    padding:10px 12px;
    outline:none; font-size:14px;
  }
  textarea{ resize:vertical; }
  .row{ display:flex; gap:10px; align-items:center; margin-top:10px; }
  .row label{ flex:1; color:var(--muted); font-size:13px; }
  .row input[type="range"]{ width:220px; }
  .row .val{ width:74px; text-align:right; font-size:13px; opacity:.95; }
  .two{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-top:10px; }
  .three{ display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; margin-top:10px; }
  .btns{ display:flex; gap:10px; margin-top:12px; flex-wrap:wrap; }
  button{
    border:1px solid rgba(255,255,255,0.14);
    background:rgba(255,255,255,0.08);
    color:var(--text);
    padding:10px 12px; border-radius:12px;
    cursor:pointer; font-weight:900;
  }
  button:hover{ background:rgba(255,255,255,0.12); }
  button.good{ background:var(--good); border-color:var(--goodBorder); }
  .hint{ margin-top:10px; color:var(--muted); font-size:13px; line-height:1.35; }
  .section{
    margin-top:14px;
    padding-top:12px;
    border-top:1px solid rgba(255,255,255,0.08);
    color:#cfe1ff;
    font-size:13px;
    letter-spacing:.2px;
  }
  .canvasWrap{ padding:12px; }
  canvas{
    width:100%; height:auto; display:block;
    background:#fff; border-radius:14px;
  }
  canvas.can-grab{ cursor: grab; }
  canvas.grabbing{ cursor: grabbing; }
  canvas.can-move-point{ cursor: move; }
  canvas.can-move-label{ cursor: grab; }
  .small{ font-size:12px; color:var(--muted); margin-top:8px; }
</style>
</head>

<body>

<div class="topbar">
  <div class="topbarInner">
    <div class="brand">
      <b>Textbook Graph Suite</b>
      <span>Tabs Navigation • Graph Paper • Fit Everywhere • Pan/Zoom • Textbook Break • Export</span>
    </div>
    <div class="tabs">
      <button class="tab active" data-tab="plotter">Dotted Point Connect</button>
      <button class="tab" data-tab="hist">Histogram + Polygon</button>
      <button class="tab" data-tab="ogive">Ogive</button>
    </div>
  </div>
</div>

<div class="wrap">

  <!-- ===================== APP 1: PLOTTER ===================== -->
  <section class="app active" id="app-plotter">
    <div class="grid">
      <div class="card">
        <h2>Controls <span class="pill">Fit • drag • pan • zoom • PNG</span></h2>
        <div class="body">

          <div class="section">Curve input</div>
          <div class="row">
            <label>Curve mode</label>
            <select id="p_mode">
              <option value="function" selected>Function</option>
              <option value="points">Points (smooth + draggable)</option>
            </select>
          </div>

          <label style="margin-top:10px;color:var(--muted);font-size:13px;">Function y = (JS in x)</label>
          <input id="p_fn" value="Math.pow(0.5, x)" />
          <div class="hint">Example: <b>Math.pow(0.5, x)</b></div>

          <label style="margin-top:10px;color:var(--muted);font-size:13px;">Points (x,y per line)</label>
          <textarea id="p_points" style="min-height:130px;">2,0.25
1,0.5
0,1
-1,2
-2,4
-3,8
-4,16
-5,32</textarea>

          <div class="row">
            <label><input id="p_showPoints" type="checkbox" checked /> Show points</label>
          </div>
          <div class="row">
            <label><input id="p_showLabels" type="checkbox" checked /> Show labels (x,y)</label>
          </div>

          <div class="section">Graph paper scale (ratio)</div>
          <div class="two">
            <div>
              <label style="color:var(--muted);font-size:13px;">x: small squares per 1 unit</label>
              <input id="p_xSmallPerUnit" type="number" value="5" min="1" step="1" />
            </div>
            <div>
              <label style="color:var(--muted);font-size:13px;">y: small squares per 1 unit</label>
              <input id="p_ySmallPerUnit" type="number" value="1" min="1" step="1" />
            </div>
          </div>

          <div class="three">
            <div>
              <label style="color:var(--muted);font-size:13px;">Minor square (px)</label>
              <input id="p_minorPx" type="number" value="10" min="4" step="1" />
            </div>
            <div>
              <label style="color:var(--muted);font-size:13px;">Major every (minor)</label>
              <input id="p_majorEvery" type="number" value="5" min="2" step="1" />
            </div>
            <div>
              <label style="color:var(--muted);font-size:13px;">Decimals</label>
              <input id="p_decimals" type="number" value="2" min="0" max="10" step="1" />
            </div>
          </div>

          <div class="section">Zoom / Styling</div>

          <div class="row">
            <label>Zoom</label>
            <input id="p_zoom" type="range" min="0.4" max="3.0" value="1.0" step="0.05" />
            <div class="val" id="p_zoomVal"></div>
          </div>

          <div class="row">
            <label>Curve thickness</label>
            <input id="p_curveWidth" type="range" min="1" max="6" value="3" step="0.1" />
            <div class="val" id="p_curveWidthVal"></div>
          </div>

          <div class="row">
            <label>Axis label font (X,Y)</label>
            <input id="p_axisFont" type="range" min="10" max="28" value="14" />
            <div class="val" id="p_axisFontVal"></div>
          </div>
          <div class="row">
            <label>Tick numbers font</label>
            <input id="p_tickFont" type="range" min="8" max="22" value="12" />
            <div class="val" id="p_tickFontVal"></div>
          </div>
          <div class="row">
            <label>Point label font</label>
            <input id="p_labelFont" type="range" min="8" max="22" value="13" />
            <div class="val" id="p_labelFontVal"></div>
          </div>

          <div class="section">Canvas</div>
          <div class="two">
            <div>
              <label style="color:var(--muted);font-size:13px;">Canvas size (w,h)</label>
              <input id="p_csize" value="920,560" />
            </div>
            <div>
              <label style="color:var(--muted);font-size:13px;">Origin (ox,oy)</label>
              <input id="p_origin" value="480,300" />
            </div>
          </div>

          <div class="btns">
            <button id="p_fit">Fit</button>
            <button id="p_draw">Draw</button>
            <button id="p_reset">Reset (sample)</button>
            <button class="good" id="p_download">Download PNG</button>
          </div>

          <div class="hint">
            ✅ <b>Pan:</b> drag empty space • ✅ <b>Move point:</b> drag a point (Points mode) • ✅ <b>Move label:</b> drag a label • ✅ <b>Zoom:</b> mouse wheel
          </div>

        </div>
      </div>

      <div class="card">
        <h2>Graph <span class="pill">single curve line</span></h2>
        <div class="canvasWrap">
          <canvas id="p_cv" width="920" height="560"></canvas>
          <div class="small">Wheel zoom keeps origin centered (Plotter). Fit centers + scales to your curve.</div>
        </div>
      </div>
    </div>
  </section>

  <!-- ===================== APP 2: HISTOGRAM ===================== -->
  <section class="app" id="app-hist">
    <div class="grid">
      <div class="card">
        <h2>Textbook Histogram + Polygon <span class="pill">Fit • 5-squares break • /\/\ • PNG/SVG</span></h2>
        <div class="body">
          <div class="hint">
            Input per line: <b>lowerBoundary, upperBoundary, frequency</b><br/>
            Example: <code>44.5,49.5,4</code>
          </div>

          <textarea id="h_data" style="min-height:155px;">44.5,49.5,4
49.5,54.5,8
54.5,59.5,10
59.5,64.5,20
64.5,69.5,12
69.5,74.5,6</textarea>

          <div class="two">
            <label style="display:flex;align-items:center;gap:10px;">
              <input id="h_showHist" type="checkbox" checked />
              <span style="color:var(--muted);font-size:13px;">Histogram</span>
            </label>
            <label style="display:flex;align-items:center;gap:10px;">
              <input id="h_showPoly" type="checkbox" checked />
              <span style="color:var(--muted);font-size:13px;">Frequency polygon</span>
            </label>
          </div>

          <div class="two">
            <label style="display:flex;align-items:center;gap:10px;">
              <input id="h_showMidDots" type="checkbox" checked />
              <span style="color:var(--muted);font-size:13px;">Midpoint dots</span>
            </label>
            <label style="display:flex;align-items:center;gap:10px;">
              <input id="h_showMidLabels" type="checkbox" />
              <span style="color:var(--muted);font-size:13px;">Midpoint labels</span>
            </label>
          </div>

          <div class="hint">
            <b>Textbook mode:</b> after the Y-axis we keep <b>5 squares</b>, draw <b>/\/\</b>,
            and start the first boundary label on the first major line.
          </div>

          <div class="row">
            <label>Zoom</label>
            <input id="h_zoom" type="range" min="0.35" max="4.0" value="1.00" step="0.05" />
            <div class="val" id="h_zoomVal"></div>
          </div>

          <div class="two">
            <div>
              <label style="color:var(--muted);font-size:13px;">Minor square (px)</label>
              <input id="h_minorPx" type="number" value="10" min="4" step="1" />
            </div>
            <div>
              <label style="color:var(--muted);font-size:13px;">Major every (squares)</label>
              <input id="h_majorEvery" type="number" value="5" min="2" step="1" />
            </div>
          </div>

          <div class="two">
            <div>
              <label style="color:var(--muted);font-size:13px;">Y labels step</label>
              <input id="h_yLabelStep" type="number" value="5" min="1" step="1" />
            </div>
            <div>
              <label style="color:var(--muted);font-size:13px;">Bar opacity</label>
              <input id="h_barAlpha" type="number" value="0.18" min="0" max="1" step="0.05" />
            </div>
          </div>

          <div class="two">
            <div>
              <label style="color:var(--muted);font-size:13px;">Canvas (w,h)</label>
              <input id="h_csize" value="980,600" />
            </div>
            <div>
              <label style="color:var(--muted);font-size:13px;">Origin (ox,oy)</label>
              <input id="h_origin" value="170,500" />
            </div>
          </div>

          <div class="two">
            <div>
              <label style="color:var(--muted);font-size:13px;">X: squares per 1 unit</label>
              <input id="h_xSmallPerUnit" type="number" value="1" min="1" step="1" />
            </div>
            <div>
              <label style="color:var(--muted);font-size:13px;">Y: squares per 1 unit</label>
              <input id="h_ySmallPerUnit" type="number" value="1" min="1" step="1" />
            </div>
          </div>

          <div class="section">Font sizes</div>

          <div class="row">
            <label>Axis letters (X,Y,O)</label>
            <input id="h_fontAxis" type="range" min="10" max="40" value="16" step="1" />
            <div class="val" id="h_fontAxisVal"></div>
          </div>

          <div class="row">
            <label>Tick labels (numbers)</label>
            <input id="h_fontTicks" type="range" min="10" max="34" value="14" step="1" />
            <div class="val" id="h_fontTicksVal"></div>
          </div>

          <div class="row">
            <label>Midpoint labels</label>
            <input id="h_fontMid" type="range" min="10" max="34" value="12" step="1" />
            <div class="val" id="h_fontMidVal"></div>
          </div>

          <div class="btns">
            <button id="h_fitBtn">Fit</button>
            <button class="good" id="h_pngBtn">PNG</button>
            <button class="good" id="h_svgBtn">SVG</button>
          </div>

          <div class="hint">
            X-axis ticks show <b>only boundaries</b>: 44.5, 49.5, 54.5, ...
          </div>
        </div>
      </div>

      <div class="card">
        <h2>Graph <span class="pill">textbook axis break + font</span></h2>
        <div class="canvasWrap">
          <canvas id="h_cv" width="980" height="600"></canvas>
          <div class="small">Pan by dragging. Zoom with wheel (zooms to cursor). Fit centers + scales.</div>
        </div>
      </div>
    </div>
  </section>

  <!-- ===================== APP 3: OGIVE ===================== -->
  <section class="app" id="app-ogive">
    <div class="grid">
      <div class="card">
        <h2>Ogive (Cumulative Frequency Curve) <span class="pill">Fit • 5-squares break • /\/\ • PNG/SVG</span></h2>
        <div class="body">

          <div class="hint">
            Input per line: <b>lowerBoundary, upperBoundary, cumulativeFrequency</b><br/>
            Example: <code>49.5,54.5,1</code><br/>
            Points plotted at <b>(firstLowerBoundary, 0)</b> and <b>(upperBoundary, cumulativeFrequency)</b>.
          </div>

          <textarea id="o_data" style="min-height:190px;">49.5,54.5,1
54.5,59.5,3
59.5,64.5,6
64.5,69.5,9
69.5,74.5,13
74.5,79.5,18
79.5,84.5,25
84.5,89.5,27
89.5,94.5,29
94.5,99.5,30</textarea>

          <div class="two">
            <label style="display:flex;align-items:center;gap:10px;">
              <input id="o_showDots" type="checkbox" checked />
              <span style="color:var(--muted);font-size:13px;">Show dots</span>
            </label>
            <label style="display:flex;align-items:center;gap:10px;">
              <input id="o_showPointLabels" type="checkbox" />
              <span style="color:var(--muted);font-size:13px;">Show point labels</span>
            </label>
          </div>

          <div class="hint">
            <b>Textbook mode:</b> from origin to the first lower boundary we show a break.
            First boundary begins after <b>5 squares</b> and uses <b>/\/\</b>.
          </div>

          <div class="row">
            <label>Zoom</label>
            <input id="o_zoom" type="range" min="0.35" max="4.0" value="1.00" step="0.05" />
            <div class="val" id="o_zoomVal"></div>
          </div>

          <div class="two">
            <div>
              <label style="color:var(--muted);font-size:13px;">Minor square (px)</label>
              <input id="o_minorPx" type="number" value="10" min="4" step="1" />
            </div>
            <div>
              <label style="color:var(--muted);font-size:13px;">Major every (squares)</label>
              <input id="o_majorEvery" type="number" value="5" min="2" step="1" />
            </div>
          </div>

          <div class="two">
            <div>
              <label style="color:var(--muted);font-size:13px;">Y labels step</label>
              <input id="o_yLabelStep" type="number" value="5" min="1" step="1" />
            </div>
            <div>
              <label style="color:var(--muted);font-size:13px;">Curve thickness</label>
              <input id="o_curveW" type="number" value="4" min="1" max="10" step="1" />
            </div>
          </div>

          <div class="two">
            <div>
              <label style="color:var(--muted);font-size:13px;">Canvas (w,h)</label>
              <input id="o_csize" value="980,600" />
            </div>
            <div>
              <label style="color:var(--muted);font-size:13px;">Origin (ox,oy)</label>
              <input id="o_origin" value="170,500" />
            </div>
          </div>

          <div class="two">
            <div>
              <label style="color:var(--muted);font-size:13px;">X: squares per 1 unit</label>
              <input id="o_xSmallPerUnit" type="number" value="1" min="1" step="1" />
            </div>
            <div>
              <label style="color:var(--muted);font-size:13px;">Y: squares per 1 unit</label>
              <input id="o_ySmallPerUnit" type="number" value="1" min="1" step="1" />
            </div>
          </div>

          <div class="section">Font sizes</div>

          <div class="row">
            <label>Axis letters (X,Y,O)</label>
            <input id="o_fontAxis" type="range" min="10" max="40" value="16" step="1" />
            <div class="val" id="o_fontAxisVal"></div>
          </div>

          <div class="row">
            <label>Tick labels (numbers)</label>
            <input id="o_fontTicks" type="range" min="10" max="34" value="14" step="1" />
            <div class="val" id="o_fontTicksVal"></div>
          </div>

          <div class="row">
            <label>Point labels</label>
            <input id="o_fontPoint" type="range" min="10" max="34" value="12" step="1" />
            <div class="val" id="o_fontPointVal"></div>
          </div>

          <div class="btns">
            <button id="o_fitBtn">Fit</button>
            <button class="good" id="o_pngBtn">PNG</button>
            <button class="good" id="o_svgBtn">SVG</button>
          </div>

        </div>
      </div>

      <div class="card">
        <h2>Graph <span class="pill">ogive curve</span></h2>
        <div class="canvasWrap">
          <canvas id="o_cv" width="980" height="600"></canvas>
          <div class="small">Pan by dragging. Zoom with wheel (zooms to cursor). Fit centers + scales.</div>
        </div>
      </div>
    </div>
  </section>

</div>

<script>
/* ===================== TAB SWITCHER ===================== */
(() => {
  const tabs = document.querySelectorAll(".tab");
  const apps = {
    plotter: document.getElementById("app-plotter"),
    hist: document.getElementById("app-hist"),
    ogive: document.getElementById("app-ogive"),
  };
  function activate(key){
    tabs.forEach(t => t.classList.toggle("active", t.dataset.tab === key));
    Object.entries(apps).forEach(([k,el]) => el.classList.toggle("active", k === key));
  }
  tabs.forEach(t => t.addEventListener("click", () => activate(t.dataset.tab)));
})();

/* ======================================================================================
   APP 1: PLOTTER (Fit ADDED), prefixed with p_
   ====================================================================================== */
(() => {
  const cv = document.getElementById('p_cv');
  const ctx = cv.getContext('2d');
  const $ = (id) => document.getElementById(id);

  const valSpans = {
    zoomVal: $('p_zoomVal'),
    curveWidthVal: $('p_curveWidthVal'),
    axisFontVal: $('p_axisFontVal'),
    tickFontVal: $('p_tickFontVal'),
    labelFontVal: $('p_labelFontVal'),
  };
  function refreshValueLabels(){
    valSpans.zoomVal.textContent = Number($('p_zoom').value).toFixed(2);
    valSpans.curveWidthVal.textContent = $('p_curveWidth').value;
    valSpans.axisFontVal.textContent = $('p_axisFont').value;
    valSpans.tickFontVal.textContent = $('p_tickFont').value;
    valSpans.labelFontVal.textContent = $('p_labelFont').value;
  }

  function parsePair(s) {
    const [a,b] = s.split(',').map(t => Number(t.trim()));
    if (!Number.isFinite(a) || !Number.isFinite(b)) return null;
    return [a,b];
  }

  function parsePoints(text) {
    return text.split('\n')
      .map(s => s.trim()).filter(Boolean)
      .map(line => {
        const [x,y] = line.split(',').map(t => Number(t.trim()));
        if(!Number.isFinite(x) || !Number.isFinite(y)) return null;
        return [x,y];
      })
      .filter(Boolean);
  }

  function stringifyPoints(points, decimals){
    const d = Math.max(0, Math.min(10, decimals|0));
    const fmt = (n) => {
      const isInt = Math.abs(n - Math.round(n)) < 1e-12;
      if (isInt) return String(Math.round(n));
      return n.toFixed(d).replace(/0+$/,'').replace(/\.$/,'');
    };
    return points.map(([x,y]) => `${fmt(x)},${fmt(y)}`).join('\n');
  }

  let pointHitBoxes = [];
  let labelHitBoxes = [];
  const labelOffsets = [];

  const drag = {
    active: false,
    mode: null, // "pan" | "point" | "label"
    pointIndex: -1,
    startMx: 0,
    startMy: 0,
    startOx: 0,
    startOy: 0,
    startDx: 0,
    startDy: 0,
  };

  function canvasXYFromEvent(e){
    const rect = cv.getBoundingClientRect();
    return {
      x: (e.clientX - rect.left) * (cv.width / rect.width),
      y: (e.clientY - rect.top) * (cv.height / rect.height),
    };
  }

  function setCanvasCursor(cls){
    cv.classList.remove("can-grab","grabbing","can-move-point","can-move-label");
    if (cls) cv.classList.add(cls);
  }

  function ensureLabelOffsets(points){
    while (labelOffsets.length < points.length) labelOffsets.push({dx: 6, dy: -6});
    if (labelOffsets.length > points.length) labelOffsets.length = points.length;
  }

  function worldToCanvas(x, y, ox, oy, minorPx, xSmallPerUnit, ySmallPerUnit, zoom) {
    const mp = minorPx * zoom;
    const sx = mp * xSmallPerUnit;
    const sy = mp * ySmallPerUnit;
    return [ox + x * sx, oy - y * sy];
  }
  function canvasToWorld(px, py, ox, oy, minorPx, xSmallPerUnit, ySmallPerUnit, zoom){
    const mp = minorPx * zoom;
    const sx = mp * xSmallPerUnit;
    const sy = mp * ySmallPerUnit;
    const x = (px - ox) / sx;
    const y = (oy - py) / sy;
    return [x, y];
  }

  function clear() {
    ctx.clearRect(0,0,cv.width,cv.height);
    ctx.fillStyle="#fff"; ctx.fillRect(0,0,cv.width,cv.height);
  }

  function drawGraphPaper(ox, oy, minorPx, majorEvery, zoom) {
    const mp = minorPx * zoom;
    const majorPx = mp * majorEvery;

    ctx.save();
    ctx.strokeStyle = "#000";

    ctx.lineWidth = 1;
    ctx.globalAlpha = 0.12;

    for (let x = ox; x <= cv.width; x += mp) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,cv.height); ctx.stroke(); }
    for (let x = ox; x >= 0; x -= mp)        { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,cv.height); ctx.stroke(); }

    for (let y = oy; y <= cv.height; y += mp){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(cv.width,y); ctx.stroke(); }
    for (let y = oy; y >= 0; y -= mp)        { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(cv.width,y); ctx.stroke(); }

    ctx.globalAlpha = 0.35;
    ctx.lineWidth = 1.5;

    for (let x = ox; x <= cv.width; x += majorPx) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,cv.height); ctx.stroke(); }
    for (let x = ox; x >= 0; x -= majorPx)        { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,cv.height); ctx.stroke(); }

    for (let y = oy; y <= cv.height; y += majorPx){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(cv.width,y); ctx.stroke(); }
    for (let y = oy; y >= 0; y -= majorPx)        { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(cv.width,y); ctx.stroke(); }

    ctx.restore();
  }

  function arrowhead(x1, y1, x2, y2, size=10) {
    const ang = Math.atan2(y2-y1, x2-x1);
    ctx.beginPath();
    ctx.moveTo(x2, y2);
    ctx.lineTo(x2 - size*Math.cos(ang - Math.PI/7), y2 - size*Math.sin(ang - Math.PI/7));
    ctx.lineTo(x2 - size*Math.cos(ang + Math.PI/7), y2 - size*Math.sin(ang + Math.PI/7));
    ctx.closePath();
    ctx.fill();
  }

  function drawAxes(ox, oy, axisWidth, axisFontPx, tickFontPx, minorPx, xSmallPerUnit, ySmallPerUnit, zoom) {
    ctx.save();
    ctx.strokeStyle = "#000";
    ctx.fillStyle = "#000";
    ctx.globalAlpha = 0.95;
    ctx.lineWidth = axisWidth;

    ctx.beginPath(); ctx.moveTo(0,oy); ctx.lineTo(cv.width,oy); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(ox,cv.height); ctx.lineTo(ox,0); ctx.stroke();

    arrowhead(0, oy, cv.width, oy, 10);
    arrowhead(ox, cv.height, ox, 0, 10);

    ctx.font = `${axisFontPx}px system-ui`;
    ctx.fillText("X", cv.width - 18, oy + 18);
    ctx.fillText("X′", 6, oy + 18);
    ctx.fillText("Y", ox + 10, 16);
    ctx.fillText("Y′", ox + 10, cv.height - 10);
    ctx.fillText("O", ox + 6, oy - 6);

    ctx.font = `${tickFontPx}px system-ui`;
    ctx.lineWidth = 1;

    const mp = minorPx * zoom;
    const sx = mp * xSmallPerUnit;
    const sy = mp * ySmallPerUnit;

    const maxXUnits = Math.ceil(Math.max(ox, cv.width-ox)/sx);
    const maxYUnits = Math.ceil(Math.max(oy, cv.height-oy)/sy);

    for (let i=-maxXUnits; i<=maxXUnits; i++) {
      const x = ox + i*sx;
      ctx.beginPath(); ctx.moveTo(x, oy-4); ctx.lineTo(x, oy+4); ctx.stroke();
      if (i!==0 && i%2===0) ctx.fillText(String(i), x-4, oy+16);
    }
    for (let j=-maxYUnits; j<=maxYUnits; j++) {
      const y = oy - j*sy;
      ctx.beginPath(); ctx.moveTo(ox-4, y); ctx.lineTo(ox+4, y); ctx.stroke();
      if (j!==0 && j%2===0) ctx.fillText(String(j), ox+8, y+4);
    }

    ctx.restore();
  }

  function safeCompileFunction(fnExpr){
    const f = new Function("x", `return (${fnExpr});`);
    // probe
    const t = f(0);
    if(!Number.isFinite(t)) throw new Error("Function not finite at x=0");
    return f;
  }

  function drawCurveFromFunction(fnExpr, ox, oy, curveWidth, minorPx, xSmallPerUnit, ySmallPerUnit, zoom) {
    let f;
    try { f = safeCompileFunction(fnExpr); }
    catch (e) { alert("Function error: " + e.message); return; }

    const mp = minorPx * zoom;
    const sx = mp * xSmallPerUnit;
    const xMin = -(ox / sx);
    const xMax = (cv.width - ox) / sx;

    ctx.save();
    ctx.strokeStyle = "#000";
    ctx.lineWidth = curveWidth;

    ctx.beginPath();
    let started = false;

    const steps = 1600;
    const step = (xMax - xMin) / steps;

    for (let x=xMin; x<=xMax; x += step) {
      const y = f(x);
      if (!Number.isFinite(y)) { started = false; continue; }
      const [px,py] = worldToCanvas(x,y,ox,oy,minorPx,xSmallPerUnit,ySmallPerUnit,zoom);
      if (!started) { ctx.moveTo(px,py); started = true; }
      else ctx.lineTo(px,py);
    }

    ctx.stroke();
    ctx.restore();
  }

  function drawCurveFromPoints(points, ox, oy, curveWidth, minorPx, xSmallPerUnit, ySmallPerUnit, zoom) {
    if (points.length < 2) return;

    points = [...points].sort((a,b)=>a[0]-b[0]);
    const p = points.map(([x,y]) => worldToCanvas(x,y,ox,oy,minorPx,xSmallPerUnit,ySmallPerUnit,zoom));

    ctx.save();
    ctx.strokeStyle = "#000";
    ctx.lineWidth = curveWidth;

    ctx.beginPath();
    ctx.moveTo(p[0][0], p[0][1]);

    for (let i=1; i<p.length-1; i++) {
      const midX = (p[i][0] + p[i+1][0]) / 2;
      const midY = (p[i][1] + p[i+1][1]) / 2;
      ctx.quadraticCurveTo(p[i][0], p[i][1], midX, midY);
    }
    ctx.lineTo(p[p.length-1][0], p[p.length-1][1]);

    ctx.stroke();
    ctx.restore();
  }

  function fmt(n, decimals) {
    if (!Number.isFinite(n)) return String(n);
    const isInt = Math.abs(n - Math.round(n)) < 1e-12;
    if (isInt) return String(Math.round(n));
    return n.toFixed(decimals).replace(/0+$/,'').replace(/\.$/,'');
  }

  function drawPointsAndLabels(points, ox, oy, minorPx, xSmallPerUnit, ySmallPerUnit, showPoints, showLabels, labelFontPx, decimals, zoom) {
    pointHitBoxes = [];
    labelHitBoxes = [];

    ctx.save();
    ctx.fillStyle = "#000";
    ctx.font = `${labelFontPx}px system-ui`;

    for (let i=0; i<points.length; i++) {
      const [x,y] = points[i];
      const [px,py] = worldToCanvas(x,y,ox,oy,minorPx,xSmallPerUnit,ySmallPerUnit,zoom);

      pointHitBoxes.push({ i, cx:px, cy:py, r:8 });

      if (showPoints) {
        ctx.beginPath();
        ctx.arc(px, py, 3.5, 0, Math.PI*2);
        ctx.fill();
      }

      if (showLabels) {
        const off = labelOffsets[i] || {dx:6, dy:-6};
        const text = `(${fmt(x,decimals)}, ${fmt(y,decimals)})`;

        const w = ctx.measureText(text).width;
        const h = labelFontPx;

        const tx = px + off.dx;
        const ty = py + off.dy;

        ctx.fillText(text, tx, ty);

        labelHitBoxes.push({ i, x: tx, y: ty - h, w: w, h: h + 4 });
      }
    }

    ctx.restore();
  }

  function applyCanvasSize() {
    const s = parsePair($('p_csize').value);
    if (!s) return alert("Canvas size format: w,h  (e.g., 920,560)");
    const [w,h] = s;
    if (!(w>100 && h>100)) return alert("Canvas size too small.");
    cv.width = Math.floor(w);
    cv.height = Math.floor(h);
  }

  function hitTestPoint(mx,my){
    for (let k=pointHitBoxes.length-1; k>=0; k--){
      const b = pointHitBoxes[k];
      const dx = mx - b.cx, dy = my - b.cy;
      if (dx*dx + dy*dy <= b.r*b.r) return b.i;
    }
    return -1;
  }
  function hitTestLabel(mx,my){
    for (let k=labelHitBoxes.length-1; k>=0; k--){
      const b = labelHitBoxes[k];
      if (mx>=b.x && mx<=b.x+b.w && my>=b.y && my<=b.y+b.h) return b.i;
    }
    return -1;
  }

  function redraw() {
    applyCanvasSize();

    const origin = parsePair($('p_origin').value);
    if (!origin) return alert("Origin format: ox,oy (e.g., 480,300)");
    const [ox,oy] = origin;

    const minorPx = Number($('p_minorPx').value);
    const majorEvery = Number($('p_majorEvery').value);
    const xSmallPerUnit = Number($('p_xSmallPerUnit').value);
    const ySmallPerUnit = Number($('p_ySmallPerUnit').value);
    const decimals = Math.max(0, Math.min(10, Number($('p_decimals').value) || 2));
    const zoom = Number($('p_zoom').value);

    const axisWidth = 2;
    const curveWidth = Number($('p_curveWidth').value);
    const axisFontPx = Number($('p_axisFont').value);
    const tickFontPx = Number($('p_tickFont').value);
    const labelFontPx = Number($('p_labelFont').value);

    const mode = $('p_mode').value;
    const showPoints = $('p_showPoints').checked;
    const showLabels = $('p_showLabels').checked;

    if (!(minorPx>0 && majorEvery>=2 && xSmallPerUnit>0 && ySmallPerUnit>0)) {
      return alert("Check minorPx / majorEvery / xSmallPerUnit / ySmallPerUnit");
    }

    const points = parsePoints($('p_points').value);
    ensureLabelOffsets(points);

    clear();
    drawGraphPaper(ox, oy, minorPx, majorEvery, zoom);
    drawAxes(ox, oy, axisWidth, axisFontPx, tickFontPx, minorPx, xSmallPerUnit, ySmallPerUnit, zoom);

    if (mode === "points") drawCurveFromPoints(points, ox, oy, curveWidth, minorPx, xSmallPerUnit, ySmallPerUnit, zoom);
    else drawCurveFromFunction($('p_fn').value, ox, oy, curveWidth, minorPx, xSmallPerUnit, ySmallPerUnit, zoom);

    drawPointsAndLabels(points, ox, oy, minorPx, xSmallPerUnit, ySmallPerUnit, showPoints, showLabels, labelFontPx, decimals, zoom);
  }

  // ✅ FIT: works for BOTH modes
  function fitToCurve(){
    applyCanvasSize();

    const minorPx = Number($('p_minorPx').value);
    const xSmallPerUnit = Number($('p_xSmallPerUnit').value);
    const ySmallPerUnit = Number($('p_ySmallPerUnit').value);

    const baseSx = minorPx * xSmallPerUnit;
    const baseSy = minorPx * ySmallPerUnit;

    const padPx = 70;
    const mode = $('p_mode').value;

    let minX=0, maxX=0, minY=0, maxY=0;
    let ok = false;

    if(mode === "points"){
      const pts = parsePoints($('p_points').value);
      if(pts.length >= 1){
        minX = Math.min(...pts.map(p=>p[0]));
        maxX = Math.max(...pts.map(p=>p[0]));
        minY = Math.min(...pts.map(p=>p[1]));
        maxY = Math.max(...pts.map(p=>p[1]));
        ok = true;
      }
    }else{
      // sample function around 0 to estimate bounds robustly
      let f;
      try { f = safeCompileFunction($('p_fn').value); }
      catch(e){ alert("Function error: " + e.message); return; }

      // choose a conservative sampling span
      const span = 10; // world units
      const samples = 800;
      minX = -span; maxX = span;
      minY = Infinity; maxY = -Infinity;

      for(let i=0;i<=samples;i++){
        const x = minX + (i/samples)*(maxX-minX);
        const y = f(x);
        if(!Number.isFinite(y)) continue;
        if(y < minY) minY = y;
        if(y > maxY) maxY = y;
      }
      if(Number.isFinite(minY) && Number.isFinite(maxY)){
        // expand slightly to avoid clipping
        const yPad = (maxY-minY) * 0.08 + 0.5;
        minY -= yPad; maxY += yPad;
        ok = true;
      }
    }

    if(!ok){
      alert("Nothing to fit (add points or fix the function).");
      return;
    }

    // avoid zero ranges
    if(Math.abs(maxX-minX) < 1e-9){ maxX += 1; minX -= 1; }
    if(Math.abs(maxY-minY) < 1e-9){ maxY += 1; minY -= 1; }

    const needZx = (cv.width - 2*padPx) / ((maxX - minX) * baseSx);
    const needZy = (cv.height - 2*padPx) / ((maxY - minY) * baseSy);
    let z = Math.min(needZx, needZy);
    z = Math.max(0.4, Math.min(3.0, z));
    $('p_zoom').value = (Math.floor(z*100)/100).toFixed(2);

    // set origin so center of bounds lands in canvas center
    const cx = (minX + maxX)/2;
    const cy = (minY + maxY)/2;

    const sx = baseSx * z;
    const sy = baseSy * z;

    const ox = cv.width/2 - cx * sx;
    const oy = cv.height/2 + cy * sy;

    $('p_origin').value = `${Math.round(ox)},${Math.round(oy)}`;

    refreshValueLabels();
    redraw();
  }

  function downloadPNG() {
    redraw();
    const a = document.createElement('a');
    const ts = new Date().toISOString().replace(/[:.]/g,'-');
    a.download = `plotter-${ts}.png`;
    a.href = cv.toDataURL("image/png");
    a.click();
  }

  function resetSample(){
    $('p_mode').value = "function";
    $('p_fn').value = "Math.pow(0.5, x)";
    $('p_points').value = `2,0.25
1,0.5
0,1
-1,2
-2,4
-3,8
-4,16
-5,32`;

    $('p_showPoints').checked = true;
    $('p_showLabels').checked = true;

    $('p_xSmallPerUnit').value = 5;
    $('p_ySmallPerUnit').value = 1;
    $('p_minorPx').value = 10;
    $('p_majorEvery').value = 5;
    $('p_decimals').value = 2;

    $('p_zoom').value = 1.0;
    $('p_curveWidth').value = 3;

    $('p_axisFont').value = 14;
    $('p_tickFont').value = 12;
    $('p_labelFont').value = 13;

    $('p_csize').value = "920,560";
    $('p_origin').value = "480,300";

    labelOffsets.length = 0;

    refreshValueLabels();
    redraw();
  }

  function updateOrigin(ox, oy){
    $('p_origin').value = `${Math.round(ox)},${Math.round(oy)}`;
  }

  cv.addEventListener("mousemove", (e) => {
    const {x:mx, y:my} = canvasXYFromEvent(e);

    if (drag.active){
      const dx = mx - drag.startMx;
      const dy = my - drag.startMy;

      if (drag.mode === "pan"){
        updateOrigin(drag.startOx + dx, drag.startOy + dy);
        redraw();
        setCanvasCursor("grabbing");
        return;
      }

      const points = parsePoints($('p_points').value);
      const origin = parsePair($('p_origin').value);
      if (!origin) return;
      const [ox,oy] = origin;

      const minorPx = Number($('p_minorPx').value);
      const xSmallPerUnit = Number($('p_xSmallPerUnit').value);
      const ySmallPerUnit = Number($('p_ySmallPerUnit').value);
      const zoom = Number($('p_zoom').value);

      if (drag.mode === "point"){
        const [wx, wy] = canvasToWorld(mx, my, ox, oy, minorPx, xSmallPerUnit, ySmallPerUnit, zoom);
        points[drag.pointIndex] = [wx, wy];
        $('p_points').value = stringifyPoints(points, Number($('p_decimals').value));
        redraw();
        setCanvasCursor("can-move-point");
        return;
      }

      if (drag.mode === "label"){
        labelOffsets[drag.pointIndex].dx = Math.round(drag.startDx + dx);
        labelOffsets[drag.pointIndex].dy = Math.round(drag.startDy + dy);
        redraw();
        setCanvasCursor("grabbing");
        return;
      }
    }

    const li = hitTestLabel(mx,my);
    const pi = hitTestPoint(mx,my);

    const mode = $('p_mode').value;
    if (li >= 0){ setCanvasCursor("can-move-label"); return; }
    if (pi >= 0 && mode === "points"){ setCanvasCursor("can-move-point"); return; }
    setCanvasCursor("can-grab");
  });

  cv.addEventListener("mousedown", (e) => {
    const {x:mx, y:my} = canvasXYFromEvent(e);

    const li = hitTestLabel(mx,my);
    if (li >= 0){
      drag.active = true;
      drag.mode = "label";
      drag.pointIndex = li;
      drag.startMx = mx;
      drag.startMy = my;
      drag.startDx = labelOffsets[li]?.dx ?? 6;
      drag.startDy = labelOffsets[li]?.dy ?? -6;
      setCanvasCursor("grabbing");
      return;
    }

    const pi = hitTestPoint(mx,my);
    if (pi >= 0 && $('p_mode').value === "points"){
      drag.active = true;
      drag.mode = "point";
      drag.pointIndex = pi;
      drag.startMx = mx;
      drag.startMy = my;
      setCanvasCursor("can-move-point");
      return;
    }

    const origin = parsePair($('p_origin').value);
    if (!origin) return;
    drag.active = true;
    drag.mode = "pan";
    drag.startMx = mx;
    drag.startMy = my;
    drag.startOx = origin[0];
    drag.startOy = origin[1];
    setCanvasCursor("grabbing");
  });

  window.addEventListener("mouseup", () => {
    drag.active = false;
    drag.mode = null;
    drag.pointIndex = -1;
    setCanvasCursor("can-grab");
  });

  // Plotter zoom: keep origin centered (your original behavior)
  cv.addEventListener("wheel", (e) => {
    e.preventDefault();
    const z = Number($('p_zoom').value);
    const delta = (e.deltaY > 0) ? 0.92 : 1.08;
    let nz = z * delta;
    nz = Math.max(0.4, Math.min(3.0, nz));

    $('p_zoom').value = nz.toFixed(2);
    refreshValueLabels();
    redraw();
  }, { passive:false });

  $('p_fit').addEventListener('click', fitToCurve);
  $('p_draw').addEventListener('click', redraw);
  $('p_download').addEventListener('click', downloadPNG);
  $('p_reset').addEventListener('click', resetSample);

  ['p_mode','p_fn','p_points','p_showPoints','p_showLabels','p_xSmallPerUnit','p_ySmallPerUnit','p_minorPx','p_majorEvery','p_decimals','p_csize','p_origin']
    .forEach(id => $(id).addEventListener('input', redraw));

  ['p_zoom','p_curveWidth','p_axisFont','p_tickFont','p_labelFont'].forEach(id => {
    $(id).addEventListener('input', () => { refreshValueLabels(); redraw(); });
  });

  refreshValueLabels();
  redraw();
  setCanvasCursor("can-grab");
})();

/* ======================================================================================
   APP 2: HISTOGRAM + FREQUENCY POLYGON (Fit INCLUDED), prefixed with h_
   ====================================================================================== */
(() => {
  const cv = document.getElementById('h_cv');
  const ctx = cv.getContext('2d');
  const $ = (id) => document.getElementById(id);

  function setVal(idSpan, idInput){
    const s = $(idSpan), i = $(idInput);
    if(s && i) s.textContent = i.value;
  }
  function refreshVals(){
    setVal('h_zoomVal','h_zoom');
    setVal('h_fontAxisVal','h_fontAxis');
    setVal('h_fontTicksVal','h_fontTicks');
    setVal('h_fontMidVal','h_fontMid');
  }

  function parsePair(s){
    const [a,b] = s.split(',').map(t => Number(t.trim()));
    if(!Number.isFinite(a) || !Number.isFinite(b)) return null;
    return [a,b];
  }

  function parseData(text){
    const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    const rows = [];
    for(const line of lines){
      const parts = line.split(',').map(s => s.trim());
      if(parts.length < 3) throw new Error("Bad line: " + line);
      const lo = Number(parts[0]), hi = Number(parts[1]), f = Number(parts[2]);
      if(!Number.isFinite(lo) || !Number.isFinite(hi) || !Number.isFinite(f)) throw new Error("Bad numbers: " + line);
      if(hi <= lo) throw new Error("Upper boundary must be > lower boundary: " + line);
      rows.push({lo, hi, f, mid:(lo+hi)/2});
    }
    rows.sort((a,b)=>a.lo-b.lo);
    return rows;
  }

  function applyCanvasSize(){
    const s = parsePair($('h_csize').value);
    if(!s) throw new Error("Canvas size format: w,h");
    const [w,h] = s;
    cv.width = Math.floor(w);
    cv.height = Math.floor(h);
  }

  function xMapWithBreak(x, ox, minorPx, xSmallPerUnit, zoom, breakFrom, breakTo, breakGapPx){
    const mp = minorPx * zoom;
    const sx = mp * xSmallPerUnit;
    if(!(breakTo > breakFrom)) return ox + x*sx;
    if(x <= breakFrom) return ox + x*sx;
    const removed = (breakTo - breakFrom);
    const xCompressed = x - removed;
    return ox + xCompressed*sx + breakGapPx;
  }

  function xUnmapWithBreak(px, ox, minorPx, xSmallPerUnit, zoom, breakFrom, breakTo, breakGapPx){
    const mp = minorPx * zoom;
    const sx = mp * xSmallPerUnit;
    if(!(breakTo > breakFrom)) return (px-ox)/sx;

    const breakFromPx = ox + breakFrom*sx;
    const afterGapStartPx = breakFromPx + breakGapPx;

    if(px <= breakFromPx) return (px-ox)/sx;
    if(px < afterGapStartPx) return breakFrom;

    const removed = (breakTo - breakFrom);
    const xCompressed = (px - ox - breakGapPx)/sx;
    return xCompressed + removed;
  }

  function worldToCanvas(x,y, params){
    const {ox,oy, minorPx, xSmallPerUnit, ySmallPerUnit, zoom, breakFrom, breakTo, breakGapPx} = params;
    const mp = minorPx * zoom;
    const sy = mp * ySmallPerUnit;
    const px = xMapWithBreak(x, ox, minorPx, xSmallPerUnit, zoom, breakFrom, breakTo, breakGapPx);
    const py = oy - y*sy;
    return [px, py];
  }

  function canvasToWorld(px,py, params){
    const {ox,oy, minorPx, xSmallPerUnit, ySmallPerUnit, zoom, breakFrom, breakTo, breakGapPx} = params;
    const mp = minorPx * zoom;
    const sy = mp * ySmallPerUnit;
    const x = xUnmapWithBreak(px, ox, minorPx, xSmallPerUnit, zoom, breakFrom, breakTo, breakGapPx);
    const y = (oy - py)/sy;
    return [x,y];
  }

  function clear(){
    ctx.clearRect(0,0,cv.width,cv.height);
    ctx.fillStyle="#fff";
    ctx.fillRect(0,0,cv.width,cv.height);
  }

  function drawGraphPaper(ox,oy, minorPx, majorEvery, zoom){
    const mp = minorPx * zoom;
    const majorPx = mp * majorEvery;

    ctx.save();
    ctx.strokeStyle="#000";

    ctx.globalAlpha=0.12; ctx.lineWidth=1;
    for(let x=ox; x<=cv.width; x+=mp){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,cv.height); ctx.stroke(); }
    for(let x=ox; x>=0; x-=mp){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,cv.height); ctx.stroke(); }
    for(let y=oy; y<=cv.height; y+=mp){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(cv.width,y); ctx.stroke(); }
    for(let y=oy; y>=0; y-=mp){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(cv.width,y); ctx.stroke(); }

    ctx.globalAlpha=0.35; ctx.lineWidth=1.5;
    for(let x=ox; x<=cv.width; x+=majorPx){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,cv.height); ctx.stroke(); }
    for(let x=ox; x>=0; x-=majorPx){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,cv.height); ctx.stroke(); }
    for(let y=oy; y<=cv.height; y+=majorPx){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(cv.width,y); ctx.stroke(); }
    for(let y=oy; y>=0; y-=majorPx){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(cv.width,y); ctx.stroke(); }

    ctx.restore();
  }

  function arrowhead(x1,y1,x2,y2,size=10){
    const ang = Math.atan2(y2-y1,x2-x1);
    ctx.beginPath();
    ctx.moveTo(x2,y2);
    ctx.lineTo(x2 - size*Math.cos(ang - Math.PI/7), y2 - size*Math.sin(ang - Math.PI/7));
    ctx.lineTo(x2 - size*Math.cos(ang + Math.PI/7), y2 - size*Math.sin(ang + Math.PI/7));
    ctx.closePath();
    ctx.fill();
  }

  function drawAxes(ox,oy, fonts){
    ctx.save();
    ctx.strokeStyle="#000";
    ctx.fillStyle="#000";
    ctx.globalAlpha=0.95;
    ctx.lineWidth=2;

    ctx.beginPath(); ctx.moveTo(0,oy); ctx.lineTo(cv.width,oy); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(ox,cv.height); ctx.lineTo(ox,0); ctx.stroke();

    arrowhead(0,oy,cv.width,oy,10);
    arrowhead(ox,cv.height,ox,0,10);

    ctx.font = `${fonts.axis}px system-ui`;
    ctx.fillText("X", cv.width-18, oy+18);
    ctx.fillText("Y", ox+10, 16);
    ctx.fillText("O", ox+6, oy-6);

    ctx.restore();
  }

  function drawAxisBreakGlyph(params){
    const {ox, oy, minorPx, majorEvery, zoom, breakTo} = params;
    if(!(breakTo > 0)) return;

    const gapPx = majorEvery * minorPx * zoom; // 5 squares region
    const cx = ox + gapPx * 0.5;
    const y = oy;

    const amp = 10;
    const step = 12;

    ctx.save();
    ctx.strokeStyle = "#000";
    ctx.lineWidth = 2;
    ctx.globalAlpha = 0.95;

    ctx.beginPath();
    ctx.moveTo(cx - step, y - amp);
    ctx.lineTo(cx - step/2, y + amp);
    ctx.lineTo(cx, y - amp);
    ctx.lineTo(cx + step/2, y + amp);
    ctx.lineTo(cx + step, y - amp);
    ctx.stroke();

    ctx.restore();
  }

  function drawYAxisLabels(params, yMax, fonts){
    const {ox,oy, minorPx, ySmallPerUnit, zoom} = params;
    const mp = minorPx * zoom;
    const sy = mp * ySmallPerUnit;
    const step = Math.max(1, Number($('h_yLabelStep')?.value ?? 5));

    ctx.save();
    ctx.fillStyle="#000";
    ctx.strokeStyle="#000";
    ctx.font = `${fonts.ticks}px system-ui`;
    ctx.globalAlpha=0.95;

    for(let y=0; y<=yMax; y+=step){
      const py = oy - y*sy;

      ctx.beginPath();
      ctx.moveTo(ox-5, py);
      ctx.lineTo(ox+5, py);
      ctx.stroke();

      if(y !== 0){
        ctx.textAlign="right";
        ctx.textBaseline="middle";
        ctx.fillText(String(y), ox-8, py);
      }
    }
    ctx.restore();
  }

  function drawXBoundaryLabels(params, boundaries, fonts){
    const {oy} = params;

    ctx.save();
    ctx.fillStyle="#000";
    ctx.strokeStyle="#000";
    ctx.font = `${fonts.ticks}px system-ui`;
    ctx.globalAlpha=0.95;

    const tickLen = 6;

    for(const b of boundaries){
      const [px] = worldToCanvas(b, 0, params);

      ctx.beginPath();
      ctx.moveTo(px, oy - tickLen);
      ctx.lineTo(px, oy + tickLen);
      ctx.stroke();

      ctx.textAlign="center";
      ctx.textBaseline="top";
      ctx.fillText(String(b), px, oy + 10);
    }
    ctx.restore();
  }

  function drawHistogram(rows, params){
    const alpha = Math.max(0, Math.min(1, Number($('h_barAlpha')?.value ?? 0.18)));

    ctx.save();
    ctx.fillStyle = "#000";

    for(const r of rows){
      const [x1,y0] = worldToCanvas(r.lo, 0, params);
      const [x2,yf] = worldToCanvas(r.hi, r.f, params);

      const left = Math.min(x1,x2);
      const right = Math.max(x1,x2);
      const top = Math.min(y0,yf);
      const bottom = Math.max(y0,yf);

      ctx.globalAlpha = alpha;
      ctx.fillRect(left, top, right-left, bottom-top);
    }

    ctx.globalAlpha = 0.45;
    ctx.strokeStyle = "#000";
    ctx.lineWidth = 1;

    for(const r of rows){
      const [x1,y0] = worldToCanvas(r.lo, 0, params);
      const [x2,yf] = worldToCanvas(r.hi, r.f, params);

      const left = Math.min(x1,x2);
      const right = Math.max(x1,x2);
      const top = Math.min(y0,yf);
      const bottom = Math.max(y0,yf);

      ctx.strokeRect(left, top, right-left, bottom-top);
    }

    ctx.restore();
  }

  function drawFrequencyPolygon(rows, params, fonts){
    if(!rows.length) return;

    const mids = rows.map(r => ({x:r.mid, y:r.f}));
    const start = {x: rows[0].lo, y:0};
    const end   = {x: rows[rows.length-1].hi, y:0};

    ctx.save();
    ctx.strokeStyle = "#000";
    ctx.globalAlpha = 1;

    ctx.lineWidth = 4;
    ctx.lineJoin = "round";
    ctx.lineCap = "round";

    ctx.beginPath();
    const [sx,sy] = worldToCanvas(start.x,start.y, params);
    ctx.moveTo(sx,sy);

    for(const p of mids){
      const [px,py] = worldToCanvas(p.x,p.y, params);
      ctx.lineTo(px,py);
    }

    const [ex,ey] = worldToCanvas(end.x,end.y, params);
    ctx.lineTo(ex,ey);
    ctx.stroke();

    if($('h_showMidDots')?.checked){
      ctx.fillStyle="#000";
      for(const p of mids){
        const [px,py] = worldToCanvas(p.x,p.y, params);
        ctx.beginPath();
        ctx.arc(px,py,4,0,Math.PI*2);
        ctx.fill();
      }
    }

    if($('h_showMidLabels')?.checked){
      ctx.fillStyle="#000";
      ctx.font = `${fonts.mid}px system-ui`;
      ctx.textAlign="center";
      ctx.textBaseline="bottom";
      for(const p of mids){
        const [px,py] = worldToCanvas(p.x,p.y, params);
        ctx.fillText(String(p.x), px, py-8);
      }
    }

    ctx.restore();
  }

  function computeBounds(rows){
    const minX = Math.min(...rows.map(r => r.lo));
    const maxX = Math.max(...rows.map(r => r.hi));
    const maxY = Math.max(...rows.map(r => r.f), 1);
    return {minX,maxX,maxY};
  }

  function readFonts(){
    return {
      axis: Number($('h_fontAxis')?.value ?? 16),
      ticks: Number($('h_fontTicks')?.value ?? 14),
      mid: Number($('h_fontMid')?.value ?? 12),
    };
  }

  function fitToData(){
    const rows = parseData($('h_data').value);
    applyCanvasSize();

    const minorPx = Number($('h_minorPx').value);
    const xSmallPerUnit = Number($('h_xSmallPerUnit').value);
    const ySmallPerUnit = Number($('h_ySmallPerUnit').value);

    const {minX,maxX,maxY} = computeBounds(rows);

    const pad = 70;
    const baseSx = minorPx * xSmallPerUnit;
    const baseSy = minorPx * ySmallPerUnit;

    const needZx = (cv.width - 2*pad) / ((maxX - minX) * baseSx);
    const needZy = (cv.height - 2*pad) / ((maxY - 0) * baseSy);
    let z = Math.min(needZx, needZy);
    z = Math.max(0.35, Math.min(4.0, z));
    $('h_zoom').value = (Math.floor(z*100)/100).toFixed(2);

    const oy = cv.height - pad;
    const ox = pad;

    $('h_origin').value = `${Math.round(ox)},${Math.round(oy)}`;
    refreshVals();
    redraw();
  }

  function redraw(){
    try{
      applyCanvasSize();
      const rows = parseData($('h_data').value);

      const origin = parsePair($('h_origin').value);
      if(!origin) throw new Error("Origin format: ox,oy");
      const [ox,oy] = origin;

      const fonts = readFonts();

      const minorPx = Number($('h_minorPx').value);
      const majorEvery = Number($('h_majorEvery').value);
      const zoom = Number($('h_zoom').value);

      const minBoundary = Math.min(...rows.map(r => r.lo));

      const breakFrom = 0;
      const breakTo = minBoundary;
      const breakGapPx = majorEvery * minorPx * zoom; // 5 squares always

      const params = {
        ox,oy,
        minorPx,
        majorEvery,
        xSmallPerUnit: Number($('h_xSmallPerUnit').value),
        ySmallPerUnit: Number($('h_ySmallPerUnit').value),
        zoom,
        breakFrom,
        breakTo,
        breakGapPx,
      };

      const {maxY} = computeBounds(rows);

      clear();
      drawGraphPaper(params.ox, params.oy, params.minorPx, params.majorEvery, params.zoom);
      drawAxes(params.ox, params.oy, fonts);
      drawAxisBreakGlyph(params);

      const boundaries = [];
      for(const r of rows) boundaries.push(r.lo);
      boundaries.push(rows[rows.length-1].hi);
      const uniq = [...new Set(boundaries)].sort((a,b)=>a-b);
      drawXBoundaryLabels(params, uniq, fonts);

      drawYAxisLabels(params, maxY, fonts);

      if($('h_showHist')?.checked) drawHistogram(rows, params);
      if($('h_showPoly')?.checked) drawFrequencyPolygon(rows, params, fonts);

    }catch(e){
      console.warn(e.message);
    }
  }

  // Pan/Zoom (Histogram): zoom-to-cursor
  function canvasXY(e){
    const r = cv.getBoundingClientRect();
    return {
      x: (e.clientX - r.left) * (cv.width / r.width),
      y: (e.clientY - r.top) * (cv.height / r.height),
    };
  }
  function setCursor(mode){
    cv.classList.remove("can-grab","grabbing");
    if(mode) cv.classList.add(mode);
  }
  let drag = {active:false, sx:0, sy:0, startOx:0, startOy:0};

  cv.addEventListener("mousedown",(e)=>{
    const p = canvasXY(e);
    const origin = parsePair($('h_origin').value);
    if(!origin) return;
    drag.active=true;
    drag.sx=p.x; drag.sy=p.y;
    drag.startOx=origin[0];
    drag.startOy=origin[1];
    setCursor("grabbing");
  });
  window.addEventListener("mouseup",()=>{ drag.active=false; setCursor("can-grab"); });

  cv.addEventListener("mousemove",(e)=>{
    if(!drag.active){ setCursor("can-grab"); return; }
    const p=canvasXY(e);
    $('h_origin').value = `${Math.round(drag.startOx + (p.x-drag.sx))},${Math.round(drag.startOy + (p.y-drag.sy))}`;
    redraw();
  });

  cv.addEventListener("wheel",(e)=>{
    e.preventDefault();
    const {x:mx,y:my} = canvasXY(e);

    const origin = parsePair($('h_origin').value);
    if(!origin) return;
    let [ox,oy]=origin;

    const minorPx = Number($('h_minorPx').value);
    const majorEvery = Number($('h_majorEvery').value);
    const xSmallPerUnit = Number($('h_xSmallPerUnit').value);
    const ySmallPerUnit = Number($('h_ySmallPerUnit').value);

    const rows = parseData($('h_data').value);
    const minBoundary = Math.min(...rows.map(r => r.lo));

    const oldZ = Number($('h_zoom').value);
    const factor = (e.deltaY > 0) ? 0.92 : 1.08;
    let newZ = Math.max(0.35, Math.min(4.0, oldZ*factor));

    const breakFrom = 0;
    const breakTo = minBoundary;
    const oldGapPx = majorEvery * minorPx * oldZ;
    const newGapPx = majorEvery * minorPx * newZ;

    const paramsOld = {ox,oy, minorPx, xSmallPerUnit, ySmallPerUnit, zoom: oldZ, breakFrom, breakTo, breakGapPx: oldGapPx};
    const [wx,wy] = canvasToWorld(mx,my, paramsOld);

    const mp2 = minorPx * newZ;
    const sx2 = mp2 * xSmallPerUnit;
    const sy2 = mp2 * ySmallPerUnit;

    const removed = (breakTo - breakFrom);

    if(wx <= breakFrom || !(breakTo > breakFrom)){
      ox = mx - wx*sx2;
    }else{
      ox = mx - (wx - removed)*sx2 - newGapPx;
    }
    oy = my + wy*sy2;

    $('h_zoom').value = (Math.floor(newZ*100)/100).toFixed(2);
    $('h_origin').value = `${Math.round(ox)},${Math.round(oy)}`;
    refreshVals();
    redraw();
  }, {passive:false});

  function downloadPNG(){
    redraw();
    const a = document.createElement("a");
    const ts = new Date().toISOString().replace(/[:.]/g,'-');
    a.download = `hist-poly-textbook-${ts}.png`;
    a.href = cv.toDataURL("image/png");
    a.click();
  }
  function downloadSVG(){
    redraw();
    const png = cv.toDataURL("image/png");
    const W=cv.width,H=cv.height;
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${W}" height="${H}" viewBox="0 0 ${W} ${H}">
      <image href="${png}" width="${W}" height="${H}" />
    </svg>`;
    const blob = new Blob([svg], {type:"image/svg+xml"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    const ts = new Date().toISOString().replace(/[:.]/g,'-');
    a.download = `hist-poly-textbook-${ts}.svg`;
    a.href = url;
    a.click();
    setTimeout(()=>URL.revokeObjectURL(url), 4000);
  }

  $('h_fitBtn').addEventListener("click", fitToData);
  $('h_pngBtn').addEventListener("click", downloadPNG);
  $('h_svgBtn').addEventListener("click", downloadSVG);

  const live = [
    'h_data','h_showHist','h_showPoly','h_showMidDots','h_showMidLabels',
    'h_zoom','h_minorPx','h_majorEvery','h_barAlpha',
    'h_yLabelStep','h_csize','h_origin','h_xSmallPerUnit','h_ySmallPerUnit',
    'h_fontAxis','h_fontTicks','h_fontMid'
  ];
  live.forEach(id => {
    const el = $(id);
    if(el) el.addEventListener("input", ()=>{ refreshVals(); redraw(); });
  });

  refreshVals();
  redraw();
  setCursor("can-grab");
})();

/* ======================================================================================
   APP 3: OGIVE (Fit INCLUDED), prefixed with o_
   ====================================================================================== */
(() => {
  const cv = document.getElementById('o_cv');
  const ctx = cv.getContext('2d');
  const $ = (id) => document.getElementById(id);

  function setVal(idSpan, idInput){
    const s = $(idSpan), i = $(idInput);
    if(s && i) s.textContent = i.value;
  }
  function refreshVals(){
    setVal('o_zoomVal','o_zoom');
    setVal('o_fontAxisVal','o_fontAxis');
    setVal('o_fontTicksVal','o_fontTicks');
    setVal('o_fontPointVal','o_fontPoint');
  }

  function parsePair(s){
    const [a,b] = s.split(',').map(t => Number(t.trim()));
    if(!Number.isFinite(a) || !Number.isFinite(b)) return null;
    return [a,b];
  }

  function parseData(text){
    const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    const rows = [];
    for(const line of lines){
      const parts = line.split(',').map(s => s.trim());
      if(parts.length < 3) throw new Error("Bad line: " + line);
      const lo = Number(parts[0]), hi = Number(parts[1]), cf = Number(parts[2]);
      if(!Number.isFinite(lo) || !Number.isFinite(hi) || !Number.isFinite(cf)) throw new Error("Bad numbers: " + line);
      if(hi <= lo) throw new Error("Upper boundary must be > lower boundary: " + line);
      rows.push({lo, hi, cf});
    }
    rows.sort((a,b)=>a.lo-b.lo);
    for(let i=1;i<rows.length;i++){
      if(rows[i].cf < rows[i-1].cf) throw new Error("Cumulative frequency must be nondecreasing (line " + (i+1) + ")");
    }
    return rows;
  }

  function applyCanvasSize(){
    const s = parsePair($('o_csize').value);
    if(!s) throw new Error("Canvas size format: w,h");
    const [w,h] = s;
    cv.width = Math.floor(w);
    cv.height = Math.floor(h);
  }

  function xMapWithBreak(x, ox, minorPx, xSmallPerUnit, zoom, breakFrom, breakTo, breakGapPx){
    const mp = minorPx * zoom;
    const sx = mp * xSmallPerUnit;
    if(!(breakTo > breakFrom)) return ox + x*sx;
    if(x <= breakFrom) return ox + x*sx;
    const removed = (breakTo - breakFrom);
    const xCompressed = x - removed;
    return ox + xCompressed*sx + breakGapPx;
  }

  function xUnmapWithBreak(px, ox, minorPx, xSmallPerUnit, zoom, breakFrom, breakTo, breakGapPx){
    const mp = minorPx * zoom;
    const sx = mp * xSmallPerUnit;
    if(!(breakTo > breakFrom)) return (px-ox)/sx;

    const breakFromPx = ox + breakFrom*sx;
    const afterGapStartPx = breakFromPx + breakGapPx;

    if(px <= breakFromPx) return (px-ox)/sx;
    if(px < afterGapStartPx) return breakFrom;

    const removed = (breakTo - breakFrom);
    const xCompressed = (px - ox - breakGapPx)/sx;
    return xCompressed + removed;
  }

  function worldToCanvas(x,y, params){
    const {ox,oy, minorPx, xSmallPerUnit, ySmallPerUnit, zoom, breakFrom, breakTo, breakGapPx} = params;
    const mp = minorPx * zoom;
    const sy = mp * ySmallPerUnit;
    const px = xMapWithBreak(x, ox, minorPx, xSmallPerUnit, zoom, breakFrom, breakTo, breakGapPx);
    const py = oy - y*sy;
    return [px, py];
  }

  function canvasToWorld(px,py, params){
    const {ox,oy, minorPx, xSmallPerUnit, ySmallPerUnit, zoom, breakFrom, breakTo, breakGapPx} = params;
    const mp = minorPx * zoom;
    const sy = mp * ySmallPerUnit;
    const x = xUnmapWithBreak(px, ox, minorPx, xSmallPerUnit, zoom, breakFrom, breakTo, breakGapPx);
    const y = (oy - py)/sy;
    return [x,y];
  }

  function clear(){
    ctx.clearRect(0,0,cv.width,cv.height);
    ctx.fillStyle="#fff";
    ctx.fillRect(0,0,cv.width,cv.height);
  }

  function drawGraphPaper(ox,oy, minorPx, majorEvery, zoom){
    const mp = minorPx * zoom;
    const majorPx = mp * majorEvery;

    ctx.save();
    ctx.strokeStyle="#000";

    ctx.globalAlpha=0.12; ctx.lineWidth=1;
    for(let x=ox; x<=cv.width; x+=mp){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,cv.height); ctx.stroke(); }
    for(let x=ox; x>=0; x-=mp){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,cv.height); ctx.stroke(); }
    for(let y=oy; y<=cv.height; y+=mp){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(cv.width,y); ctx.stroke(); }
    for(let y=oy; y>=0; y-=mp){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(cv.width,y); ctx.stroke(); }

    ctx.globalAlpha=0.35; ctx.lineWidth=1.5;
    for(let x=ox; x<=cv.width; x+=majorPx){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,cv.height); ctx.stroke(); }
    for(let x=ox; x>=0; x-=majorPx){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,cv.height); ctx.stroke(); }
    for(let y=oy; y<=cv.height; y+=majorPx){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(cv.width,y); ctx.stroke(); }
    for(let y=oy; y>=0; y-=majorPx){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(cv.width,y); ctx.stroke(); }

    ctx.restore();
  }

  function arrowhead(x1,y1,x2,y2,size=10){
    const ang = Math.atan2(y2-y1,x2-x1);
    ctx.beginPath();
    ctx.moveTo(x2,y2);
    ctx.lineTo(x2 - size*Math.cos(ang - Math.PI/7), y2 - size*Math.sin(ang - Math.PI/7));
    ctx.lineTo(x2 - size*Math.cos(ang + Math.PI/7), y2 - size*Math.sin(ang + Math.PI/7));
    ctx.closePath();
    ctx.fill();
  }

  function readFonts(){
    return {
      axis: Number($('o_fontAxis')?.value ?? 16),
      ticks: Number($('o_fontTicks')?.value ?? 14),
      point: Number($('o_fontPoint')?.value ?? 12),
    };
  }

  function drawAxes(ox,oy, fonts){
    ctx.save();
    ctx.strokeStyle="#000";
    ctx.fillStyle="#000";
    ctx.globalAlpha=0.95;
    ctx.lineWidth=2;

    ctx.beginPath(); ctx.moveTo(0,oy); ctx.lineTo(cv.width,oy); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(ox,cv.height); ctx.lineTo(ox,0); ctx.stroke();

    arrowhead(0,oy,cv.width,oy,10);
    arrowhead(ox,cv.height,ox,0,10);

    ctx.font = `${fonts.axis}px system-ui`;
    ctx.fillText("X", cv.width-18, oy+18);
    ctx.fillText("Y", ox+10, 16);
    ctx.fillText("O", ox+6, oy-6);

    ctx.restore();
  }

  function drawAxisBreakGlyph(params){
    const {ox, oy, minorPx, majorEvery, zoom, breakTo} = params;
    if(!(breakTo > 0)) return;

    const gapPx = majorEvery * minorPx * zoom;
    const cx = ox + gapPx * 0.5;
    const y = oy;

    const amp = 10;
    const step = 12;

    ctx.save();
    ctx.strokeStyle = "#000";
    ctx.lineWidth = 2;
    ctx.globalAlpha = 0.95;

    ctx.beginPath();
    ctx.moveTo(cx - step, y - amp);
    ctx.lineTo(cx - step/2, y + amp);
    ctx.lineTo(cx, y - amp);
    ctx.lineTo(cx + step/2, y + amp);
    ctx.lineTo(cx + step, y - amp);
    ctx.stroke();

    ctx.restore();
  }

  function drawYAxisLabels(params, yMax, fonts){
    const {ox,oy, minorPx, ySmallPerUnit, zoom} = params;
    const mp = minorPx * zoom;
    const sy = mp * ySmallPerUnit;
    const step = Math.max(1, Number($('o_yLabelStep')?.value ?? 5));

    ctx.save();
    ctx.fillStyle="#000";
    ctx.strokeStyle="#000";
    ctx.font = `${fonts.ticks}px system-ui`;
    ctx.globalAlpha=0.95;

    for(let y=0; y<=yMax; y+=step){
      const py = oy - y*sy;

      ctx.beginPath();
      ctx.moveTo(ox-5, py);
      ctx.lineTo(ox+5, py);
      ctx.stroke();

      if(y !== 0){
        ctx.textAlign="right";
        ctx.textBaseline="middle";
        ctx.fillText(String(y), ox-8, py);
      }
    }
    ctx.restore();
  }

  function drawXUpperBoundaryLabels(params, upperBounds, fonts){
    const {oy} = params;

    ctx.save();
    ctx.fillStyle="#000";
    ctx.strokeStyle="#000";
    ctx.font = `${fonts.ticks}px system-ui`;
    ctx.globalAlpha=0.95;

    const tickLen = 6;

    for(const b of upperBounds){
      const [px] = worldToCanvas(b, 0, params);

      ctx.beginPath();
      ctx.moveTo(px, oy - tickLen);
      ctx.lineTo(px, oy + tickLen);
      ctx.stroke();

      ctx.textAlign="center";
      ctx.textBaseline="top";
      ctx.fillText(String(b), px, oy + 10);
    }

    ctx.restore();
  }

  function drawOgiveCurve(points, params, fonts){
    if(points.length < 2) return;

    const w = Math.max(1, Number($('o_curveW')?.value ?? 4));

    ctx.save();
    ctx.strokeStyle="#000";
    ctx.lineWidth=w;
    ctx.lineJoin="round";
    ctx.lineCap="round";

    ctx.beginPath();
    let [x0,y0] = worldToCanvas(points[0].x, points[0].y, params);
    ctx.moveTo(x0,y0);
    for(let i=1;i<points.length;i++){
      const [px,py] = worldToCanvas(points[i].x, points[i].y, params);
      ctx.lineTo(px,py);
    }
    ctx.stroke();

    if($('o_showDots')?.checked){
      ctx.fillStyle="#000";
      for(const p of points){
        const [px,py] = worldToCanvas(p.x,p.y, params);
        ctx.beginPath(); ctx.arc(px,py,4,0,Math.PI*2); ctx.fill();
      }
    }

    if($('o_showPointLabels')?.checked){
      ctx.fillStyle="#000";
      ctx.font = `${fonts.point}px system-ui`;
      ctx.textAlign="left";
      ctx.textBaseline="bottom";
      for(const p of points){
        const [px,py] = worldToCanvas(p.x,p.y, params);
        ctx.fillText(`(${p.x}, ${p.y})`, px+8, py-8);
      }
    }

    ctx.restore();
  }

  function computeBounds(rows){
    const minX = Math.min(...rows.map(r => r.lo));
    const maxX = Math.max(...rows.map(r => r.hi));
    const maxY = Math.max(...rows.map(r => r.cf), 1);
    return {minX,maxX,maxY};
  }

  function buildOgivePoints(rows){
    const minLo = rows[0].lo;
    const pts = [{x: minLo, y: 0}];
    for(const r of rows) pts.push({x: r.hi, y: r.cf});
    return pts;
  }

  function fitToData(){
    const rows = parseData($('o_data').value);
    applyCanvasSize();

    const minorPx = Number($('o_minorPx').value);
    const xSmallPerUnit = Number($('o_xSmallPerUnit').value);
    const ySmallPerUnit = Number($('o_ySmallPerUnit').value);

    const {minX,maxX,maxY} = computeBounds(rows);

    const pad = 70;
    const baseSx = minorPx * xSmallPerUnit;
    const baseSy = minorPx * ySmallPerUnit;

    const needZx = (cv.width - 2*pad) / ((maxX - minX) * baseSx);
    const needZy = (cv.height - 2*pad) / ((maxY - 0) * baseSy);
    let z = Math.min(needZx, needZy);
    z = Math.max(0.35, Math.min(4.0, z));
    $('o_zoom').value = (Math.floor(z*100)/100).toFixed(2);

    const oy = cv.height - pad;
    const ox = pad;

    $('o_origin').value = `${Math.round(ox)},${Math.round(oy)}`;
    refreshVals();
    redraw();
  }

  function redraw(){
    try{
      applyCanvasSize();
      const rows = parseData($('o_data').value);
      if(rows.length === 0) return;

      const origin = parsePair($('o_origin').value);
      if(!origin) throw new Error("Origin format: ox,oy");
      const [ox,oy] = origin;

      const fonts = readFonts();

      const minorPx = Number($('o_minorPx').value);
      const majorEvery = Number($('o_majorEvery').value);
      const zoom = Number($('o_zoom').value);

      const firstLowerBoundary = rows[0].lo;

      const breakFrom = 0;
      const breakTo = firstLowerBoundary;
      const breakGapPx = majorEvery * minorPx * zoom;

      const params = {
        ox,oy,
        minorPx,
        majorEvery,
        xSmallPerUnit: Number($('o_xSmallPerUnit').value),
        ySmallPerUnit: Number($('o_ySmallPerUnit').value),
        zoom,
        breakFrom,
        breakTo,
        breakGapPx,
      };

      const {maxY} = computeBounds(rows);

      clear();
      drawGraphPaper(params.ox, params.oy, params.minorPx, params.majorEvery, params.zoom);
      drawAxes(params.ox, params.oy, fonts);
      drawAxisBreakGlyph(params);

      const upperBounds = rows.map(r => r.hi);
      const xLabels = [rows[0].lo, ...upperBounds];
      drawXUpperBoundaryLabels(params, xLabels, fonts);

      drawYAxisLabels(params, maxY, fonts);

      const pts = buildOgivePoints(rows);
      drawOgiveCurve(pts, params, fonts);

    }catch(e){
      console.warn(e.message);
    }
  }

  // Pan/Zoom (Ogive): zoom-to-cursor
  function canvasXY(e){
    const r = cv.getBoundingClientRect();
    return {
      x: (e.clientX - r.left) * (cv.width / r.width),
      y: (e.clientY - r.top) * (cv.height / r.height),
    };
  }
  function setCursor(mode){
    cv.classList.remove("can-grab","grabbing");
    if(mode) cv.classList.add(mode);
  }
  let drag = {active:false, sx:0, sy:0, startOx:0, startOy:0};

  cv.addEventListener("mousedown",(e)=>{
    const p = canvasXY(e);
    const origin = parsePair($('o_origin').value);
    if(!origin) return;
    drag.active=true;
    drag.sx=p.x; drag.sy=p.y;
    drag.startOx=origin[0];
    drag.startOy=origin[1];
    setCursor("grabbing");
  });
  window.addEventListener("mouseup",()=>{ drag.active=false; setCursor("can-grab"); });

  cv.addEventListener("mousemove",(e)=>{
    if(!drag.active){ setCursor("can-grab"); return; }
    const p=canvasXY(e);
    $('o_origin').value = `${Math.round(drag.startOx + (p.x-drag.sx))},${Math.round(drag.startOy + (p.y-drag.sy))}`;
    redraw();
  });

  cv.addEventListener("wheel",(e)=>{
    e.preventDefault();
    const {x:mx,y:my} = canvasXY(e);

    const origin = parsePair($('o_origin').value);
    if(!origin) return;
    let [ox,oy]=origin;

    const minorPx = Number($('o_minorPx').value);
    const majorEvery = Number($('o_majorEvery').value);
    const xSmallPerUnit = Number($('o_xSmallPerUnit').value);
    const ySmallPerUnit = Number($('o_ySmallPerUnit').value);

    const rows = parseData($('o_data').value);
    const firstLowerBoundary = rows[0].lo;

    const oldZ = Number($('o_zoom').value);
    const factor = (e.deltaY > 0) ? 0.92 : 1.08;
    let newZ = Math.max(0.35, Math.min(4.0, oldZ*factor));

    const breakFrom = 0;
    const breakTo = firstLowerBoundary;
    const oldGapPx = majorEvery * minorPx * oldZ;
    const newGapPx = majorEvery * minorPx * newZ;

    const paramsOld = {ox,oy, minorPx, xSmallPerUnit, ySmallPerUnit, zoom: oldZ, breakFrom, breakTo, breakGapPx: oldGapPx};
    const [wx,wy] = canvasToWorld(mx,my, paramsOld);

    const mp2 = minorPx * newZ;
    const sx2 = mp2 * xSmallPerUnit;
    const sy2 = mp2 * ySmallPerUnit;

    const removed = (breakTo - breakFrom);

    if(wx <= breakFrom || !(breakTo > breakFrom)){
      ox = mx - wx*sx2;
    }else{
      ox = mx - (wx - removed)*sx2 - newGapPx;
    }
    oy = my + wy*sy2;

    $('o_zoom').value = (Math.floor(newZ*100)/100).toFixed(2);
    $('o_origin').value = `${Math.round(ox)},${Math.round(oy)}`;
    refreshVals();
    redraw();
  }, {passive:false});

  function downloadPNG(){
    redraw();
    const a = document.createElement("a");
    const ts = new Date().toISOString().replace(/[:.]/g,'-');
    a.download = `ogive-textbook-${ts}.png`;
    a.href = cv.toDataURL("image/png");
    a.click();
  }
  function downloadSVG(){
    redraw();
    const png = cv.toDataURL("image/png");
    const W=cv.width,H=cv.height;
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${W}" height="${H}" viewBox="0 0 ${W} ${H}">
      <image href="${png}" width="${W}" height="${H}" />
    </svg>`;
    const blob = new Blob([svg], {type:"image/svg+xml"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    const ts = new Date().toISOString().replace(/[:.]/g,'-');
    a.download = `ogive-textbook-${ts}.svg`;
    a.href = url;
    a.click();
    setTimeout(()=>URL.revokeObjectURL(url), 4000);
  }

  $('o_fitBtn').addEventListener("click", fitToData);
  $('o_pngBtn').addEventListener("click", downloadPNG);
  $('o_svgBtn').addEventListener("click", downloadSVG);

  const live = [
    'o_data','o_showDots','o_showPointLabels',
    'o_zoom','o_minorPx','o_majorEvery','o_yLabelStep','o_curveW',
    'o_csize','o_origin','o_xSmallPerUnit','o_ySmallPerUnit',
    'o_fontAxis','o_fontTicks','o_fontPoint'
  ];
  live.forEach(id => {
    const el = $(id);
    if(el) el.addEventListener("input", ()=>{ refreshVals(); redraw(); });
  });

  refreshVals();
  redraw();
  setCursor("can-grab");
})();
</script>

</body>
</html>
